###### Bezier

<img src="images/BezierCurves/NothingToCurve3.gif" class="alignImg"></img>
I have been interested in learning how to make smoother movement and animations with code and have started learning bezier curves and splines.
<img src="images/BezierCurves/Spline1.gif" class="alignImg"></img>
I started with making simple bezier curves using Unity's Vector3.lerp function. I made a cubic and quadratic curve quite simply, and found it more efficent.
equations. With these equations I learned that the derivatives could be used to find movement direction and acceleration (shown with the direction marked green above).
Using this I found a tutorial explaining splines to help create the above spline editor.

<img src="images/BezierCurves/Bezier1.png"></img>
<img src="images/BezierCurves/Bezier4.png" style="width: 50%"></img>

This tutorial showed me the great usage of unity editor functions and tools, alongside how they can be made to increase working speeds and clarity of code. The above image shows some of the code that I made to place unity handles for each spline point.
<img src="images/BezierCurves/Baseball.gif" class="alignImg"></img>

#######Carnival Carnage

<img src="images/VrProject/VrProject.gif" class="alignImg"></img>
<p>During my advanced diploma of games development, we were placed into a team of three designers, three programmers, and three artists that would act as though they were 
contracted to only produce the assets to a given brief.
Small note: I currently do not have images associated with the project, but by the 15th of January one of the designers with a working Oculus Quest will be 
recording gameplay to fill in this page.
Carnival Carnage is a vr arcade game in which the player must smash clown heads within a time limit with a hammer that can return to them.
<!--<img src="images/RapidDelivery/RapidDeliverySceneView.gif" class="alignImg"></img>-->
<li>Working In Vr</li>
Working with Unity's OpenXr development environment was a challenge that provided alot of learning for me and the team. The requirement to make everything into a prefab
and to be very specific on what changes had to be made to the player controller allowed us to learn about the importance of communication and structuring git commits
to be informative.
<br>
I learned a lot about learning itself through needing to fill in the blanks while reading documentation that is not the most informative for troubleshooting.
Getting to work on Vr was also alot of fun for testing as our game included destructables from throwing the hammer.
<!--<img src="images/RapidDelivery/TemplatedEnvironment.png" class="alignImg"></img>-->
<li>Planning for assets</li>
Due to the limited time that we were given to complete this project. The art team was considered to be contractors working to a set brief. This gave me a lot of learning
opportunities as we had to really design the game and mechanics to accommodate the lack of changes that could be made to the art.
A build will be uploaded when we can confirm with an oculus that it has been built correctly.


######### Node Graph
<h1>Node Graph Generator</h1>
<img src="images/Complex/NodeGraphExample.gif" class="alignImg"></img>
<p>For my complex games systems assessment, I wanted to work with AI, but immediately ran into problems with Unity's inbuilt navmesh system as it was hard to operate with custom locomotion. I then
decided to create a simple to use node graph generator. This generator would take an object as an environment and use it to create a node graph on top of it.
<img src="images/Complex/ComplexOne.png" class="alignImg"></img>
<p>To make it simple to use I made the system require a single object; this could be an empty child that has multiple hundreds of objects; the reasoning for this was so all objects are
accounted for under the one "environment" object, so there is never any that are not included in the process of creating the graph.
Currently all the simple objects in the above image are all under one container empty GameObject.
<img src="images/Complex/ComplexFiltering.png" class="alignImg"></img>
<p>One of the first problems that I ran into with this system was filtering out the vertices of objects that were not needed. The solution to this was a dot product check against that object's other vertices to make sure that they were not underneath another vertex within a set distance. If they were then they are ignored. After this is done on all objects in the environment they are then collected into a single list container where they are filtered by distance, and heights to remove overlaps, placed into a node class and given connections then all the node objects are then collected into a single array to be used as a node graph.
<br><br> After this whole process is done, the array is also loaded into a NodeGraphContainer scriptable object to be saved so the generation process only needs to occur once.
<br><br>The final result is a fully ready node graph that can be generated from many different models or environments that AI can then traverse. The Ai in this example uses simple steering
behaviours.
<br>The unity package if you wish to use it is <a href="https://github.com/ThomasLambProgramming/NodeGraph" target="_blank">available here</a>
<img src="images/Complex/ComplexAssessment.gif" class="alignImg"></img>


#### 2nd year project
<h1>Malicious</h1>
<img src="images/Malicious/MaliciousTitle.png" class="alignImg"></img>
<p>For the final project of my advanced diploma of games development, I was placed into a group of 7 developers with 3 artists, 3 designers, and myself as the sole programmer.
The game that we developed is a 3D Puzzle Platformer where you play as a virus that must escape from its creator.
<br>
This game brought alot of challenges and I learned alot about developing as a team.
<img src="images/Malicious/Malicious1.gif" class="alignImg"></img>
<li>Hacking Mechanic</li>
One of the biggest challenges that this project brought was the hacking mechanic. This mechanic was challenging for me as it required me to learn how to develop
more modular and reusable code as this hacking mechanic had to work alongside the enemy, blocks, drone, spring and wire mechanics. I solved this issue by making a
base class of hackable that was then inherited by all the mechanics that needed it. allowing the player to enter and exit without affecting any of the code for that specific mechanic itself.
<img src="images/Malicious/Malicious2.gif" class="alignImg"></img>
<li>Wire Mechanic</li>
To add verticality to the platforming without directly allowing the player to jump up all the blocks, the designers came up with the wire mechanic.
This mechanic allows the player to enter into a wire and use the wasd, space and ctrl keys to place wires and move along them. The wire does raycasts
to check if a wire can be placed and is checked against a layer mask to give the designers more options. The player also has a limit on the amount of moves they can do.
At any time the player can launch themselves out of the wire in the direction they are facing.
<img src="images/Malicious/Malicious3.gif" class="alignImg"></img>
<li>Fan Mechanic</li>
This fan mechanic taught me the most about games development in a team. This mechanic had a few smaller features to make it a better fan then just applying force in a direction such as a dot product check for the current objects velocity and apply extra force accordingly (this was done to allow for smoother fan pushing when the fan was horizontally pushing), the fan also used a different force to push based on the distance away from the object it was pushing. I implemented this because I wanted a smarter fan then just pushing it. This however led me to learn quite alot, as when explaining the fan to my other team members, they didn't understand what I was trying to add to the fan, and it caused a lot of communication issues.
I learned a lot from this experience as it taught me how to communicate with less technically knowledgeable team members, the need for tooling and variable limit setting, good descriptions (in Unity's case tooltips) and most importantly, knowing when something actually adds to the game rather than wasting time adding extra features that will not be noticed by the general player base and spending time refining what will be noticed.
<p class="listCentertext">This ground enemy shown below just had simple seek behaviors with a limited turning speed. It acts as one of the main dangers to the player.</p>
<img src="images/Malicious/Malicious4.gif" class="alignImg"></img>	
Our final game was fully playable with a full sprint schedule of alpha, beta, and gold. Our end result had very few bugs and none of them were game breaking.
<br>The final build is avaiable on <a href="https://haydencarterdesign.itch.io/malicious" target="_blank">itch here.</a>


###### First year project

<h1>Rapid Delivery</h1>
<img src="images/RapidDelivery/RapidDeliveryGameplay.gif" class="alignImg"></img>
<p>As part of my diploma of games development, I was put into a small team of six developers over six weeks and we created an endless runner game where the player must maneuver their car around
obstacles while delivering tea to customers from their cannon on the top of the car. 
<img src="images/RapidDelivery/RapidDeliverySceneView.gif" class="alignImg"></img>
<li>Road generation and obstacles</li>
<p class="listText">The road object is split into ten meter chunks that are instantiated at set intervals. This road object covers all three lanes and is not separated.
For the spawning of obstacles, we have six different prefabs that are instantiated into the game beyond what the player can see and are deleted when they collide with a trigger box behind the player.
Npc customers will spawn along the sidewalk at random intervals; when the player is in range the cannon will aim at the closest customer allowing the player to shoot tea at them.
<img src="images/RapidDelivery/TemplatedEnvironment.png" class="alignImg"></img>
<li>Tileset Envionment</li>
Due to our limited time of six weeks and the fact that we only had two artists, we made all of our environment tiled. They all have a base of a set size, and our designers 
worked with the artists to create small environment prefabs of the same size to allow for the constant spawning of environment without them being in the wrong position.
<br><br>Our final game was fully playable with a nice and simple UI. We managed to get small details in such as the falling and raising ! mark for customers and etc.
<img src="images/RapidDelivery/FirstYearMajorTwo.gif" class="alignImg"></img>